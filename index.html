<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SkyDive Pro: Queda Livre v2.0</title>
    <style>
        /* --- UI & UX --- */
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; user-select: none; touch-action: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* HUD */
        .hud-panel {
            padding: 20px; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            display: flex; justify-content: space-between; align-items: flex-start;
            flex-wrap: wrap;
            z-index: 5;
        }
        .stat-box { background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 8px; backdrop-filter: blur(5px); border-left: 4px solid #00d2ff; margin: 5px; }
        .stat-label { font-size: 12px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1px; }
        .stat-value { font-size: 24px; font-weight: bold; font-family: monospace; }
        
        @media (max-width: 768px) {
            .hud-panel { padding: 10px; }
            .stat-box { padding: 8px 15px; }
            .stat-label { font-size: 10px; }
            .stat-value { font-size: 18px; }
        }
        
        /* MIRA / CROSSHAIR */
        #crosshair {
            width: 40px; height: 40px; 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 4;
        }
        /* Estilo padr√£o (bolinha) para 1¬™ pessoa */
        .crosshair-dot {
            width: 20px !important; height: 20px !important;
            border: 2px solid rgba(255,255,255,0.8); border-radius: 50%;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            background: transparent;
        }
        /* Estilo imagem para 3¬™ pessoa */
        .crosshair-img {
            background-image: url('img3.png');
            width: 64px !important; height: 64px !important;
            border: none !important; border-radius: 0 !important;
            box-shadow: none !important;
        }

        #altimeter-bar {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
            width: 10px; height: 300px; background: rgba(255,255,255,0.2); border-radius: 5px; overflow: hidden;
        }
        #altimeter-fill {
            width: 100%; height: 100%; background: linear-gradient(to top, #ff0000, #ffff00, #00ff00);
            transform-origin: bottom; transform: scaleY(1); transition: transform 0.1s;
        }
        
        @media (max-width: 768px) {
            #altimeter-bar { height: 200px; width: 8px; right: 10px; }
        }

        /* Virtual Joystick */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px; height: 150px;
            pointer-events: auto;
            display: none; /* Controlled via JS now */
            z-index: 100;
        }
        
        #joystick-outer {
            width: 100%; height: 100%;
            background: rgba(100, 100, 100, 0.4);
            border-radius: 50%;
            position: relative;
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        #joystick-inner {
            width: 60%; height: 60%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255,255,255,0.1);
        }

        /* NOVOS BOT√ïES MOBILE */
        .mobile-controls-area {
            position: absolute; bottom: 40px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
            pointer-events: none;
        }
        .mobile-btn {
            width: 80px; height: 80px;
            border-radius: 50%;
            background: rgba(0, 210, 255, 0.5);
            border: 2px solid #fff;
            color: white; font-weight: bold; font-size: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transition: transform 0.1s, background 0.2s;
            text-transform: uppercase; text-align: center;
        }
        .mobile-btn:active { transform: scale(0.9); background: rgba(0, 210, 255, 0.8); }
        
        /* Esconde bot√µes no desktop se quiser, mas deixaremos vis√≠vel para teste se redimensionar */
        @media (min-width: 769px) {
            .mobile-controls-area { display: none; }
        }

        /* Menus */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 15, 30, 0.90); backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; color: white; z-index: 200;
            overflow-y: auto;
        }
        .hidden { display: none !important; }
        
        h1 { font-size: 60px; margin: 0; background: linear-gradient(45deg, #00d2ff, #3a7bd5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        h2 { font-size: 30px; margin-bottom: 20px; color: #eee; }
        h3 { color: #00d2ff; margin-top: 0; }
        p { font-size: 18px; color: #ccc; max-width: 600px; text-align: center; line-height: 1.6; padding: 0 20px; }
        
        button {
            padding: 15px 40px; font-size: 20px; border: none; border-radius: 50px;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5); color: white;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; font-weight: bold; margin-top: 20px;
        }
        button:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(0, 210, 255, 0.6); }

        /* Notifications */
        #message-area {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: 32px; font-weight: bold; color: #ffcc00; text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 10;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <div class="stat-box">
                <div class="stat-label">Altitude</div>
                <div class="stat-value"><span id="alt-val">4000</span> m</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Pontos</div>
                <div class="stat-value" id="score-val">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">N√≠vel</div>
                <div class="stat-value" id="level-val">1</div>
            </div>
        </div>
        
        <div id="crosshair" class="crosshair-dot"></div>
        
        <div id="altimeter-bar">
            <div id="altimeter-fill"></div>
        </div>

        <div id="message-area"></div>
        
        <div id="joystick-container">
            <div id="joystick-outer">
                <div id="joystick-inner"></div>
            </div>
        </div>

        <div class="mobile-controls-area">
            <div id="btn-cam-mobile" class="mobile-btn">
                üì∑<br>Vis√£o
            </div>
            <div style="width: 100px;"></div> 
            <div id="btn-chute-mobile" class="mobile-btn" style="background: rgba(255, 100, 0, 0.6);">
                ü™Ç<br>Abrir
            </div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1>SKYDIVE PRO</h1>
        <h2>Mobile Edition</h2>
        <p>
           <b>Objetivo:</b> Atravesse os an√©is para pontuar.<br>
           <b>Controles Mobile:</b> Use o joystick central para mover.<br>
           Bot√£o ESQUERDO troca a c√¢mera.<br>
           Bot√£o DIREITO abre/fecha o paraquedas.<br>
           Voc√™ pode abrir o paraquedas a qualquer momento!
        </p>
        <button id="btn-start">INICIAR MISS√ÉO</button>
        
        <div style="margin-top: 20px; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
            <div style="display: flex; justify-content: space-between; width: 200px;">
                <span>Recorde:</span> <span id="high-score">0</span>
            </div>
        </div>
    </div>

    <div id="end-screen" class="screen hidden">
        <h1 id="end-title">FIM DE JOGO</h1>
        <h2 id="end-score">Pontua√ß√£o: 0</h2>
        <p id="end-reason"></p>
        <button id="btn-restart">PR√ìXIMO SALTO</button>
    </div>

    <div id="pause-screen" class="screen hidden">
        <h1>PAUSADO</h1>
        <button id="btn-resume-pause">CONTINUAR</button>
        <button id="btn-restart-pause" style="background: #e74c3c;">REINICIAR</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { ImprovedNoise } from 'https://unpkg.com/three@0.160.0/examples/jsm/math/ImprovedNoise.js';

        // --- Configura√ß√µes do Jogo Modificadas ---
        const START_ALTITUDE = 4500;
        const GRAVITY = 9.8;
        const TERMINAL_VELOCITY = 95; // AUMENTADO (era 55) para ser mais r√°pido
        const PARACHUTE_VELOCITY = 8; 
        const DRAG_COEF = 0.05;
        const TERRAIN_SIZE = 10000;
        const TERRAIN_RESOLUTION = 128;
        
        // Sensibilidade de movimento
        const MOVE_SPEED_FREEFALL = 120; // AUMENTADO para mais mobilidade
        const MOVE_SPEED_CHUTE = 30;

        // --- Vari√°veis Globais ---
        let scene, camera, renderer;
        let gameState = 'MENU';
        let currentLevel = 1;
        let terrainSeed = 0; // Para randomizar o terreno
        
        let player = {
            pos: new THREE.Vector3(0, START_ALTITUDE, 0),
            vel: new THREE.Vector3(0, 0, 0),
            parachuteOpen: false,
            score: 0
        };
        
        let mouse = new THREE.Vector2();
        let keys = { w: false, a: false, s: false, d: false };
        let joystickInput = new THREE.Vector2();
        
        let rings = [];
        let clouds = [];
        let terrainMesh;
        let landingZone;
        
        // √Åudio
        let audioCtx, windNode, gainNode;

        let lastFrameTime = performance.now();
        let isFirstPerson = true;
        let playerModel;
        let characterTexture1, characterTexture2;

        // Elementos DOM
        const uiAlt = document.getElementById('alt-val');
        const uiScore = document.getElementById('score-val');
        const uiLevel = document.getElementById('level-val');
        const uiAltFill = document.getElementById('altimeter-fill');
        const msgArea = document.getElementById('message-area');
        const crosshair = document.getElementById('crosshair');
        const joystickContainer = document.getElementById('joystick-container');
        
        const startScreen = document.getElementById('start-screen');
        const endScreen = document.getElementById('end-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const highScoreEl = document.getElementById('high-score');
        
        const btnChute = document.getElementById('btn-chute-mobile');
        const btnCam = document.getElementById('btn-cam-mobile');

        let highScore = localStorage.getItem('skydive_highscore_v2') || 0;
        highScoreEl.innerText = highScore;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 18000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 30000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Luzes
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(2000, 4000, 2000);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = TERRAIN_SIZE;
            dirLight.shadow.camera.bottom = -TERRAIN_SIZE;
            dirLight.shadow.camera.left = -TERRAIN_SIZE;
            dirLight.shadow.camera.right = TERRAIN_SIZE;
            scene.add(dirLight);

            // Texturas
            const textureLoader = new THREE.TextureLoader();
            characterTexture1 = textureLoader.load('img1.png');
            characterTexture2 = textureLoader.load('img2.png');

            // Inicializa√ß√£o de objetos
            createPlayerModel();
            initJoystick();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            
            // Mouse/Teclado PC
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Bot√µes Mobile
            btnChute.addEventListener('touchstart', (e) => { e.preventDefault(); toggleParachute(); });
            btnChute.addEventListener('mousedown', (e) => { e.preventDefault(); toggleParachute(); });
            
            btnCam.addEventListener('touchstart', (e) => { e.preventDefault(); toggleCamera(); });
            btnCam.addEventListener('mousedown', (e) => { e.preventDefault(); toggleCamera(); });

            document.getElementById('btn-start').addEventListener('click', startGame);
            document.getElementById('btn-restart').addEventListener('click', resetGame);
            document.getElementById('btn-resume-pause').addEventListener('click', togglePause);
            document.getElementById('btn-restart-pause').addEventListener('click', resetGame);
        }

        function generateLevel(level) {
            // Limpar n√≠vel anterior
            if(terrainMesh) scene.remove(terrainMesh);
            if(landingZone) scene.remove(landingZone);
            rings.forEach(r => scene.remove(r));
            rings = [];
            clouds.forEach(c => scene.remove(c));
            clouds = [];

            // Randomizar semente do terreno baseado no n√≠vel
            terrainSeed = Math.random() * 1000 + level * 100;
            createTerrain(terrainSeed);
            createClouds();
            createRings(level);
        }

        function createTerrain(seed) {
            const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE * 2, TERRAIN_SIZE * 2, TERRAIN_RESOLUTION, TERRAIN_RESOLUTION);
            const perlin = new ImprovedNoise();
            const data = [];
            const zScale = 400;

            for (let i = 0; i < TERRAIN_RESOLUTION + 1; i++) {
                for (let j = 0; j < TERRAIN_RESOLUTION + 1; j++) {
                    const x = (i / TERRAIN_RESOLUTION) - 0.5;
                    const y = (j / TERRAIN_RESOLUTION) - 0.5;
                    // Usando seed offset
                    let h = perlin.noise(x * 5 + seed, y * 5 + seed, 0) * 0.5;
                    h += perlin.noise(x * 10 + seed, y * 10 + seed, 0) * 0.25;
                    h = Math.pow(Math.abs(h), 2) * zScale;
                    data.push(h);
                }
            }

            const vertices = geometry.attributes.position.array;
            for (let i = 0, j = 0; i < vertices.length; i += 3, j++) {
                vertices[i + 2] = data[j];
            }
            geometry.computeVertexNormals();
            geometry.rotateX(-Math.PI / 2);

            const material = new THREE.MeshStandardMaterial({ vertexColors: true, flatShading: true });
            const colors = [];
            const color = new THREE.Color();
            for (let i = 0, j = 0; i < vertices.length; i += 3, j++) {
                const h = data[j];
                if (h < 20) color.setHex(0x204070); // √Ågua
                else if (h < 80) color.setHex(0x228b22); // Grama
                else if (h < 200) color.setHex(0x8b4513); // Terra
                else color.setHex(0xffffff); // Neve
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));

            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);

            // Zona de Pouso (Alvo)
            const targetGeo = new THREE.CircleGeometry(80, 32); // Maior
            const targetMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            landingZone = new THREE.Mesh(targetGeo, targetMat);
            landingZone.rotation.x = -Math.PI / 2;
            const hCenter = getHeightAtCoordinates(0, 0);
            landingZone.position.y = hCenter + 5;
            scene.add(landingZone);
        }

        function getHeightAtCoordinates(x, z) {
            // Fun√ß√£o simplificada de altura
            // Em uma implementa√ß√£o real complexa, raycasting √© melhor, mas aqui estimamos pelo grid
            // Retorna base segura
            return 20; 
        }

        function createRings(level) {
            const geometry = new THREE.TorusGeometry(25, 4, 16, 50); // An√©is maiores
            const material = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            
            let pattern = level % 3; // 0: Linha/Curva, 1: Espiral, 2: Random
            
            for(let i=0; i < 25; i++) {
                const ring = new THREE.Mesh(geometry, material);
                let x, z;
                let y = 4000 - (i * 150); // Espa√ßamento vertical

                if (pattern === 0) {
                    // Curva suave
                    x = Math.sin(i * 0.3) * 300;
                    z = Math.cos(i * 0.3) * 300;
                } else if (pattern === 1) {
                    // Espiral larga
                    const radius = 500 - (i * 10);
                    const angle = i * 0.8;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                } else {
                    // Aleat√≥rio disperso (dif√≠cil)
                    x = (Math.random() - 0.5) * 1000;
                    z = (Math.random() - 0.5) * 1000;
                }

                ring.position.set(x, y, z);
                ring.rotation.x = Math.PI / 2;
                ring.userData = { active: true };
                scene.add(ring);
                rings.push(ring);
            }
        }

        function createClouds() {
            const cloudGeo = new THREE.BoxGeometry(1, 1, 1);
            const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
            for(let i=0; i<100; i++) {
                const cloud = new THREE.Group();
                const s = 20 + Math.random()*30;
                const m = new THREE.Mesh(cloudGeo, cloudMat);
                m.scale.set(s, s/2, s);
                cloud.add(m);
                cloud.position.set((Math.random()-0.5)*4000, 1000+Math.random()*3000, (Math.random()-0.5)*4000);
                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        function createPlayerModel() {
            playerModel = new THREE.Group();
            
            const bodyGeo = new THREE.PlaneGeometry(40, 40);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                map: characterTexture1, transparent: true, side: THREE.DoubleSide, alphaTest: 0.1 
            });
            const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
            bodyMesh.castShadow = true;
            playerModel.add(bodyMesh);
            playerModel.userData.bodyMesh = bodyMesh;

            const parachuteGeo = new THREE.SphereGeometry(35, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const parachuteMat = new THREE.MeshStandardMaterial({ color: 0xff6600, side: THREE.DoubleSide });
            const parachuteMesh = new THREE.Mesh(parachuteGeo, parachuteMat);
            parachuteMesh.position.y = 30;
            parachuteMesh.visible = false;
            playerModel.add(parachuteMesh);
            playerModel.userData.parachuteMesh = parachuteMesh;

            scene.add(playerModel);
        }

        function initJoystick() {
            const outer = document.getElementById('joystick-outer');
            const inner = document.getElementById('joystick-inner');
            let active = false;
            let startPos = { x: 0, y: 0 };

            const handleStart = (e) => {
                active = true;
                const touch = e.touches ? e.touches[0] : e;
                const rect = outer.getBoundingClientRect();
                startPos = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
            };

            const handleMove = (e) => {
                if (!active) return;
                const touch = e.touches ? e.touches[0] : e;
                const dx = touch.clientX - startPos.x;
                const dy = touch.clientY - startPos.y;
                const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
                const angle = Math.atan2(dy, dx);
                
                joystickInput.x = (Math.cos(angle) * dist) / 40;
                joystickInput.y = (Math.sin(angle) * dist) / 40;
                
                inner.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
            };

            const handleEnd = () => {
                active = false;
                joystickInput.set(0,0);
                inner.style.transform = 'translate(-50%, -50%)';
            };

            outer.addEventListener('touchstart', handleStart);
            document.addEventListener('touchmove', handleMove); // Document para n√£o perder se sair da √°rea
            document.addEventListener('touchend', handleEnd);
            outer.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);
        }

        // --- Sistema de √Åudio Simplificado ---
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            
            // Som de Vento
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            windNode = audioCtx.createBufferSource();
            windNode.buffer = buffer;
            windNode.loop = true;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0;
            windNode.connect(filter).connect(gainNode).connect(audioCtx.destination);
            windNode.start();
        }

        function playCollectSound() {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime); // A5
            osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.1);
            g.gain.setValueAtTime(0.1, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.connect(g).connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        function startGame() {
            if (!audioCtx) initAudio();
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

            startScreen.classList.add('hidden');
            joystickContainer.style.display = 'block'; // Mostra joystick s√≥ agora
            
            gameState = 'PLAYING';
            
            // Gera n√≠vel
            generateLevel(currentLevel);
            uiLevel.innerText = currentLevel;

            player.pos.set(0, START_ALTITUDE, 0);
            player.vel.set(0, 0, 0);
            player.parachuteOpen = false;
            player.score = 0;
            
            updatePlayerVisuals();
            isFirstPerson = true;
            updateCrosshairVisual();
            
            lastFrameTime = performance.now();
            showMessage("MISS√ÉO INICIADA!");
        }

        function toggleParachute() {
            if(gameState !== 'PLAYING') return;
            
            player.parachuteOpen = !player.parachuteOpen;
            
            if (player.parachuteOpen) {
                showMessage("PARAQUEDAS ABERTO!");
                btnChute.innerHTML = "‚úÇÔ∏è<br>CORTAR";
                btnChute.style.background = "rgba(255, 0, 0, 0.6)";
            } else {
                showMessage("QUEDA LIVRE!");
                btnChute.innerHTML = "ü™Ç<br>ABRIR";
                btnChute.style.background = "rgba(255, 100, 0, 0.6)";
            }
            updatePlayerVisuals();
        }

        function updatePlayerVisuals() {
            playerModel.userData.parachuteMesh.visible = player.parachuteOpen;
            if(playerModel.userData.bodyMesh) {
                playerModel.userData.bodyMesh.material.map = player.parachuteOpen ? characterTexture2 : characterTexture1;
            }
        }

        function toggleCamera() {
            isFirstPerson = !isFirstPerson;
            playerModel.visible = !isFirstPerson;
            updateCrosshairVisual();
        }

        function updateCrosshairVisual() {
            if(isFirstPerson) {
                crosshair.className = "crosshair-dot";
            } else {
                crosshair.className = "crosshair-img";
            }
        }

        function showMessage(text) {
            msgArea.innerText = text;
            msgArea.style.opacity = 1;
            setTimeout(() => { msgArea.style.opacity = 0; }, 2000);
        }

        function togglePause() {
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                pauseScreen.classList.remove('hidden');
                joystickContainer.style.display = 'none';
                if (audioCtx) audioCtx.suspend();
            } else if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                pauseScreen.classList.add('hidden');
                joystickContainer.style.display = 'block';
                lastFrameTime = performance.now();
                if (audioCtx) audioCtx.resume();
            }
        }

        function resetGame() {
            endScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            joystickContainer.style.display = 'none';
            // Se morreu, reseta n√≠vel? Ou mant√©m? Vamos manter para tentar de novo.
            startGame();
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        }
        function onKeyDown(e) {
            if(e.key === 'w') keys.w = true;
            if(e.key === 's') keys.s = true;
            if(e.key === 'a') keys.a = true;
            if(e.key === 'd') keys.d = true;
            if(e.key === ' ') toggleParachute();
            if(e.key === 'Control') toggleCamera();
        }
        function onKeyUp(e) {
            if(e.key === 'w') keys.w = false;
            if(e.key === 's') keys.s = false;
            if(e.key === 'a') keys.a = false;
            if(e.key === 'd') keys.d = false;
        }

        function updatePhysics(dt) {
            const speed = player.parachuteOpen ? PARACHUTE_VELOCITY : TERMINAL_VELOCITY;
            const moveSpeed = player.parachuteOpen ? MOVE_SPEED_CHUTE : MOVE_SPEED_FREEFALL;
            
            // Gravidade vs Drag
            let targetYVel = -speed;
            player.vel.y = THREE.MathUtils.lerp(player.vel.y, targetYVel, dt * 2);

            // Movimento Horizontal
            let mx = joystickInput.x;
            let mz = joystickInput.y;
            if (!mx && !mz) { // Se n√£o tem joystick, usa teclado/mouse
                mx = (keys.d ? 1 : 0) - (keys.a ? 1 : 0) + mouse.x;
                mz = (keys.s ? 1 : 0) - (keys.w ? 1 : 0) - mouse.y;
            }

            player.vel.x = THREE.MathUtils.lerp(player.vel.x, mx * moveSpeed, dt * 3);
            player.vel.z = THREE.MathUtils.lerp(player.vel.z, mz * moveSpeed, dt * 3);

            player.pos.addScaledVector(player.vel, dt);

            // Rota√ß√£o do modelo
            playerModel.position.copy(player.pos);
            if (!isFirstPerson) playerModel.userData.bodyMesh.lookAt(camera.position);
            playerModel.rotation.z = -player.vel.x * 0.002; // Inclina√ß√£o visual
            playerModel.rotation.x = player.vel.z * 0.002;

            // Ch√£o
            if (player.pos.y <= 20) {
                handleLanding();
            }
        }

        function checkCollisions() {
            rings.forEach(ring => {
                if(ring.userData.active) {
                    // Raio aumentado para 40 (era 15) para pegar nas bordas
                    const dist = Math.sqrt( Math.pow(player.pos.x - ring.position.x, 2) + Math.pow(player.pos.z - ring.position.z, 2) );
                    const vDist = Math.abs(player.pos.y - ring.position.y);
                    
                    if(dist < 40 && vDist < 30) {
                        player.score += 100;
                        ring.userData.active = false;
                        ring.visible = false;
                        playCollectSound();
                        showMessage("+100!");
                    }
                }
            });
        }

        function handleLanding() {
            gameState = 'ENDED';
            joystickContainer.style.display = 'none';
            const distToCenter = Math.sqrt(player.pos.x**2 + player.pos.z**2);
            
            if (!player.parachuteOpen) {
                document.getElementById('end-title').innerText = "VOC√ä SE ARREBENTOU!";
                document.getElementById('end-title').style.color = "red";
                document.getElementById('end-reason').innerText = "Esqueceu o paraquedas?";
            } else {
                document.getElementById('end-title').innerText = "POUSO BEM SUCEDIDO!";
                document.getElementById('end-title').style.color = "#00ff00";
                let bonus = 0;
                if (distToCenter < 100) bonus = 500;
                else if (distToCenter < 300) bonus = 200;
                
                player.score += bonus;
                document.getElementById('end-reason').innerText = `B√¥nus de Alvo: +${bonus}`;
                
                // Avan√ßa n√≠vel
                currentLevel++;
            }

            endScreen.classList.remove('hidden');
            document.getElementById('end-score').innerText = "Pontua√ß√£o Final: " + player.score;
            
            if(player.score > highScore) {
                highScore = player.score;
                localStorage.setItem('skydive_highscore_v2', highScore);
                highScoreEl.innerText = highScore;
            }
            
            if(gainNode) gainNode.gain.value = 0;
        }

        function updateCamera() {
            if (isFirstPerson) {
                camera.position.copy(player.pos);
                // Olha levemente para baixo na dire√ß√£o do movimento
                const target = player.pos.clone().add(new THREE.Vector3(player.vel.x, -100, player.vel.z));
                camera.lookAt(target);
            } else {
                // Vis√£o Top-Down estilo drone
                camera.position.set(player.pos.x, player.pos.y + 150, player.pos.z + 50);
                camera.lookAt(player.pos);
            }
        }

        function updateHUD() {
            uiAlt.innerText = Math.floor(player.pos.y);
            uiScore.innerText = player.score;
            const pct = Math.max(0, Math.min(player.pos.y / START_ALTITUDE, 1));
            uiAltFill.style.transform = `scaleY(${pct})`;
            
            if (audioCtx && gainNode) {
                const vol = Math.min(Math.abs(player.vel.y) / TERMINAL_VELOCITY, 1);
                gainNode.gain.setTargetAtTime(vol * 0.3, audioCtx.currentTime, 0.1);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const dt = Math.min((time - lastFrameTime) / 1000, 0.1);
            lastFrameTime = time;

            if (gameState === 'PLAYING') {
                updatePhysics(dt);
                checkCollisions();
                updateHUD();
            }
            
            updateCamera();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
